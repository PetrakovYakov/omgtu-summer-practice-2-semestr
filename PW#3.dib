#!meta

{"kernelInfo":{"defaultKernelName":"csharp","items":[{"aliases":[],"languageName":"csharp","name":"csharp"}]}}

#!markdown

# Практическая работа №1. Знакомство с потоками.

**Цель:** Познакомиться с возможностями класса System.Thread платформы .NET Framework.

**Результаты:** После выполнения работы Вы сможете:
1. Запускать длительные операции в отдельном потоке.
2. Завершать поток.
3. Дожидаться завершения выполнения потока. 


**Материалы для самостоятельного изучения**.
1. [Основы управления потоками](https://learn.microsoft.com/en-us/dotnet/standard/threading/managed-threading-basics)
2. [Использование потоков](https://learn.microsoft.com/en-us/dotnet/standard/threading/using-threads-and-threading)
3. [Примитив синхронизации Барьер](https://learn.microsoft.com/ru-ru/dotnet/standard/threading/barrier)
4. [Interlocked операции](https://learn.microsoft.com/en-us/dotnet/api/system.threading.interlocked?view=net-8.0)

## Задание.
Реализовать вычисление определенного интеграла методом трапеции в несколько потоков.

Отрезок, на котором происходит вычисление, разбивается на отрезки по количеству потоков. Для каждого отрезка значение 
интеграла считается в отдельном потоке, после завершения вычисоения полученный рельтаты суммирутся.

**Указание**.
1. Для суммирования результатов удобно воспользоваться разделяемой переменной, к которой будут прибалятся результаты вычисления прямо в самом потоке. Для синхронизации операций сложения лучше всего восользоваться [Interlocked операцией](https://learn.microsoft.com/en-us/dotnet/api/system.threading.interlocked?view=net-8.0).
2. Основная функция долна дождаться завершения всех потоков, которые вычисляют значение на отрезках, прежде чем возвратить результат. Для этого удобнее всего использовать Примитив синхронизации Барьер](https://learn.microsoft.com/ru-ru/dotnet/standard/threading/barrier).

#!csharp

using System.Threading;
using static System.Threading.Barrier;

class DefiniteIntegral
{
    public static double Solve(double a, double b, Func<double, double> function, double step, int threadsnumber)
    {
        double result = 0.0;
        double segment = (b - a) / threadsnumber;
        Barrier barrier = new Barrier(threadsnumber + 1);
        for (int i = 0; i < threadsnumber; i++)
        {
            double start = a + i * segment; 
            double end = start + segment;
            Thread t1 = new Thread(() =>
            {
                double segmentresult = 0;
                segmentresult += 0.5 * (function(start) + function(end)); 
                double q = (end - start) / step;
                for (int j = 1; j < q; j++)
                {
                    double x = start + j * step;
                    segmentresult += function(x);
                }
                segmentresult *= step;
                double newresult, output;
                do
                {
                    newresult = result;
                    output = newresult + segmentresult;
                } 
                while (Interlocked.CompareExchange(ref result, output, newresult) != newresult);
                barrier.SignalAndWait(); 
            });
            t1.Start();
        }
        barrier.SignalAndWait();
        return result;
    }
}

#!csharp

public static double Solve1 (double a, double b, Func<double, double> function1, double step1) 
{
    double res1 = 0;
    int w = Convert.ToInt32((b-a)/step1);
    for(int i=0; i<w; i++)
    {
        double x = a + i*step1;
        res1+=function1(x);
    }
    res1*=step1;
    return res1;
}

#!csharp

using System.Diagnostics;
var SIN = (double x) => Math.Sin(x);
double[] output = new double[6];
double[] steps = { 1e-1, 1e-2, 1e-3, 1e-4, 1e-5, 1e-6 };
List<double> optimalsteps = new List<double>();
for (int i = 0; i < steps.Length; i++)
{
    var stopwatch = Stopwatch.StartNew();
    output[i] = Solve1(-100, 100, SIN, steps[i]);
    stopwatch.Stop();
    double time = stopwatch.Elapsed.TotalMilliseconds;
    Console.WriteLine($"{steps[i]} : {time} мс : {output[i]}");
}

#!markdown

Итог: оптимальный шаг - 1e-5

#!csharp

using System.Diagnostics;
#r "nuget:ScottPlot, 5.0.35"
using Microsoft.DotNet.Interactive.Formatting;
Formatter.Register(typeof(ScottPlot.Plot), (p, w) => 
    w.Write(((ScottPlot.Plot)p).GetImageHtml(400, 300)), HtmlFormatter.MimeType);
long[] dataX_time= new long[15];
double[] dataY_threads = new double[15];
int runs = 10;
int optimal = 0;
long min = long.MaxValue;
double step = 1e-5;
for (int threads = 0; threads < 15; threads++)
{
    long time = 0;
    dataY_threads[threads] = threads+2;
    for (int j = 0; j < runs; j++)
    {
        var stopwatch = Stopwatch.StartNew();
        DefiniteIntegral.Solve(-100, 100, SIN, step, threads+2);
        stopwatch.Stop();
        time += stopwatch.ElapsedMilliseconds;
    }
    dataX_time[threads] = time / runs;
    if (dataX_time[threads] < min)
    {
        min = dataX_time[threads];
        optimal = threads;
    }
}
long avgsolvetime = dataX_time[optimal];
Console.WriteLine($"Оптимальное число потоков - {dataY_threads[optimal]}, время выполнения:  {dataX_time[optimal]} мс");
ScottPlot.Plot plt = new();
plt.Add.Scatter(dataX_time, dataY_threads);
plt

#!csharp

long solve1time = 0;
for (int i = 0; i < runs; i++)
{
    var stopwatch = Stopwatch.StartNew();
    Solve1(-100, 100, SIN, step);
    stopwatch.Stop();
    solve1time += stopwatch.ElapsedMilliseconds;
}
long avgsolve1time = solve1time / runs;
Console.WriteLine($"Время выполнения однопоточной версии {avgsolve1time} мс")

#!csharp

double difference = (100 - avgsolvetime *100 / avgsolve1time);
Console.WriteLine($"Оптимальный шаг: 1e-5");
Console.WriteLine($"Оптимальное кол-во потоков: {dataY_threads[optimal]}");
Console.WriteLine($"Среднее время работы многопоточной версии: {dataX_time[optimal]} мс");
Console.WriteLine($"Среднее время работы однопоточной версии: {avgsolve1time} мс");
Console.WriteLine($"Разница в скорости: {difference}%");
